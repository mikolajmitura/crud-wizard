pl.jalokim.crudwizard.core.validation.javax.WhenFieldIsInStateThenOthersShould.message={nestedMessage} - ale tylko gdy pole {whenField} {is}{fieldValues}
pl.jalokim.crudwizard.core.validation.javax.FieldShouldWhenOther.message=powinno {should}{fieldValues} gdy pole {whenField} {is}{otherFieldValues}
pl.jalokim.crudwizard.core.validation.javax.FieldShouldWhenOther.messageWithoutWhen=powinno {should}{fieldValues}

shouldBe.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.NULL=być null
whenIs.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.NULL=jest null
shouldBe.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.NOT_NULL=nie być null
whenIs.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.NOT_NULL=nie jest null
shouldBe.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.EQUAL_TO_ANY=być równe do jednego z:
whenIs.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.EQUAL_TO_ANY=jest równe do jednego z:
shouldBe.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.CONTAINS_ALL=zawierać wszystkie:
whenIs.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.CONTAINS_ALL=zawiera wszystkie:
shouldBe.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.CONTAINS_ANY=zawierać jeden z:
whenIs.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.CONTAINS_ANY=zawiera jedno z:
shouldBe.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.NOT_EQUAL_TO_ALL=nie być równe do żadnego z:
whenIs.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.NOT_EQUAL_TO_ALL=jest inne niż wszystkie:
shouldBe.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.EMPTY=być puste
whenIs.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.EMPTY=jest puste
shouldBe.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.EMPTY_OR_NULL=być puste lub null
whenIs.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.EMPTY_OR_NULL=jest puste lub null
shouldBe.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.NOT_BLANK=nie być puste
whenIs.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.NOT_BLANK=nie jest puste
shouldBe.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.NOT_EMPTY=nie być puste
whenIs.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.NOT_EMPTY=nie jest puste
shouldBe.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.MIN=mieć rozmiar/wartość większą lub równą:
whenIs.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.MIN=ma rozmiar/wartość większą lub równą:
shouldBe.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.MAX=mieć rozmiar/wartość mniejszą lub równą:
whenIs.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.MAX=ma rozmiar/wartość mniejszą lub równą:

pl.jalokim.crudwizard.genericapp.metamodel.endpoint.validation.PathParamsAndUrlVariablesTheSame.message=zmienne URL z '{baseUrl}' muszą być zgodnę z nazwami pól z {fieldName}: '{fieldNames}'
pl.jalokim.crudwizard.genericapp.metamodel.endpoint.validation.PathParamsAndUrlVariablesTheSame.allFieldsShouldHasClassName=wszystkie zmienne URL muszą mieć podaną prostą klasę typu Long lub String.

pl.jalokim.crudwizard.genericapp.metamodel.endpoint.validation.EndpointNotExistsAlready.crudWizardController=Url: '{url}' wraz z HTTP metodą: '{httpMethod}' jest już zajęty poprzez endpoint o URL: '{foundUrl}' i nazwie operacji '{foundOperationName}'
pl.jalokim.crudwizard.genericapp.metamodel.endpoint.validation.EndpointNotExistsAlready.springRestController=Url: '{url}' wraz z HTTP metodą: '{httpMethod}' jest już zajęty poprzez Spring RestController: {restClassAndMethod}'

pl.jalokim.crudwizard.genericapp.metamodel.endpoint.validation.DataStorageResultsJoinCorrectness.invalidJoinersNumber=nie poprawna ilość w stosunku do ilości źródeł danych.
pl.jalokim.crudwizard.genericapp.metamodel.endpoint.validation.DataStorageResultsJoinCorrectness.nonUniqueDsOrQueryName=Nazwa zapytania albo nazwa źródła danych powinna być unikalna
pl.jalokim.crudwizard.genericapp.metamodel.endpoint.validation.DataStorageResultsJoinCorrectness.notFound=Nie znaleziono tej wartości w nazwach zapytań lub źródeł danych.
pl.jalokim.crudwizard.genericapp.metamodel.endpoint.validation.DataStorageResultsJoinCorrectness.existsInTheSameGroupAlready=Nazwy zapytań lub źródeł danych już istnieją w grupie: {0}
pl.jalokim.crudwizard.genericapp.metamodel.endpoint.validation.DataStorageResultsJoinCorrectness.notOneGroupResults=Nie poprawny wynik złączeń. Znalezione groupy: {0} a powinna być jedna.
pl.jalokim.crudwizard.genericapp.metamodel.endpoint.validation.DataStorageResultsJoinCorrectness.notTheSameTypesForJoin=różne typy danych dla złączeń z lewej: {leftType}, z prawej: {rightType}


javax.validation.constraints.AssertFalse.message     = powinno być fałsz
javax.validation.constraints.AssertTrue.message      = powinno być prawdą
javax.validation.constraints.DecimalMax.message      = powinno być mniej niż ${inclusive == true ? 'lub równe ' : ''}{value}
javax.validation.constraints.DecimalMin.message      = powinno być więcej niż ${inclusive == true ? 'lub równe ' : ''}{value}
javax.validation.constraints.Digits.message          = wartości numeryczne po za zakresem (<{integer} cyfry>.<{fraction} cyfry> oczekiwane)
javax.validation.constraints.Email.message           = niepoprawny adres e-mail
javax.validation.constraints.Future.message          = powinna być data w przyszłości
javax.validation.constraints.FutureOrPresent.message = powinna być obecna data lub z przyszłości
javax.validation.constraints.Max.message             = powinno być mniej niż lub równe {value}
javax.validation.constraints.Min.message             = powinno być więcej niż lub równe {value}
javax.validation.constraints.Negative.message        = powinno być mniej niż 0
javax.validation.constraints.NegativeOrZero.message  = powinno być mniej niż lub równe 0
javax.validation.constraints.NotBlank.message        = nie powinno być puste
javax.validation.constraints.NotEmpty.message        = nie powinno być puste
javax.validation.constraints.NotNull.message         = nie powinno być null
javax.validation.constraints.Null.message            = powinno być null
javax.validation.constraints.Past.message            = powinna być data z przeszłości
javax.validation.constraints.PastOrPresent.message   = powinna być data z przeszłości lub obecna
javax.validation.constraints.Pattern.message         = musi pasować do "{regexp}"
javax.validation.constraints.Positive.message        = powinno być więcej niż 0
javax.validation.constraints.PositiveOrZero.message  = powinno być więcej niż lub równe 0
javax.validation.constraints.Size.message            = rozmiar powinien być w przedziale od {min} do {max}

org.hibernate.validator.constraints.Email.message                   = niepoprawnie sformatowany adres email
org.hibernate.validator.constraints.Length.message                  = długość powinna być w przedziale od {min} do {max}
org.hibernate.validator.constraints.CodePointLength.message         = długość powinna być w przedziale od {min} do {max}
org.hibernate.validator.constraints.NotBlank.message                = nie powinno być puste
org.hibernate.validator.constraints.NotEmpty.message                = nie powinno być puste
org.hibernate.validator.constraints.Range.message                   = powinna być w przedziale od {min} do {max}
org.hibernate.validator.constraints.UniqueElements.message          = powinno zawierać tylko unikalne elementy
org.hibernate.validator.constraints.URL.message                     = powinien być poprawnym adresem URL

ResourceChangedException.default.message=Zasób został zmodyfikowany przez innego użytkownika
EntityNotFoundException.default.message=Nie można znaleźć zasobu o id: {0}
EntityNotFoundException.default.concrete.message=Nie można znaleźć zasobu o id: {0} dla tabeli: {1}

ClassMetaModelTypeExtractor.invalid.path=ścieżka: '{currentPath}' rozwiązana do typu: {currentNodeType}, nie zawiera pola pod nazwą '{fieldName}'.
ClassMetaModelTypeExtractor.not.expected.any.field=ścieżka: '{currentPath}' rozwiązana do typu: {currentNodeType}, jest typem prostym, nie może zawierać pól.

pl.jalokim.crudwizard.core.validation.javax.ClassExists.message=Nie można znaleźć klasy lub nie jest podtypem klasy: {expectedOfType}
pl.jalokim.crudwizard.core.validation.javax.UniqueValue.message=Wartość powinna być unikalna
pl.jalokim.crudwizard.genericapp.metamodel.datastorage.validation.VerifyThatCanCreateDataStorage.message=Nie można znaleźć domyślnej fabryki dla magazyny danych
classMetaModel.java.lang.String=Tekst

org.hibernate.validator.constraints.CreditCardNumber.message=niepoprawny numer karty kredytowej
org.hibernate.validator.constraints.Currency.message=niepoprawna wartość waluty(musi być jedną z {value})
org.hibernate.validator.constraints.EAN.message=niepoprawny {type} kod kreskowy
org.hibernate.validator.constraints.ISBN.message=niepoprawny ISBN
org.hibernate.validator.constraints.LuhnCheck.message=cyfra kontrolna dla ${validatedValue} jest nieprawidłowa, suma kontrolna Luhna Modulo 10 nie powiodła się
org.hibernate.validator.constraints.Mod10Check.message=cyfra kontrolna dla ${validatedValue} jest nieprawidłowa, suma kontrolna Modulo 10 nie powiodła się
org.hibernate.validator.constraints.Mod11Check.message=cyfra kontrolna dla ${validatedValue} jest nieprawidłowa, suma kontrolna Modulo 11 nie powiodła się
org.hibernate.validator.constraints.ModCheck.message=cyfra kontrolna dla ${validatedValue} jest nieprawidłowa, suma kontrolna ${modType} nie powiodła się
org.hibernate.validator.constraints.ParametersScriptAssert.message=wyrażenie skryptu „{script}” nie zostało rozwiązane jako prawda
org.hibernate.validator.constraints.SafeHtml.message=może zawierać niebezpieczną zawartość HTML
org.hibernate.validator.constraints.ScriptAssert.message=wyrażenie skryptu „{script}” nie zostało wyliczone jako prawda
org.hibernate.validator.constraints.br.CNPJ.message=nieprawidłowy brazylijski numer rejestracyjny podatnika korporacyjnego (CNPJ)
org.hibernate.validator.constraints.br.CPF.message=nieprawidłowy brazylijski indywidualny numer rejestracyjny podatnika (CPF)
org.hibernate.validator.constraints.br.TituloEleitoral.message=nieprawidłowy numer brazylijskiej karty identyfikacyjnej wyborcy
org.hibernate.validator.constraints.pl.NIP.message=nieprawidłowy numer identyfikacji podatkowej REGON
org.hibernate.validator.constraints.pl.PESEL.message=nieprawidłowy numer identyfikacyjny VAT (NIP)
org.hibernate.validator.constraints.pl.REGON.message=nieprawidłowy numer PESEL
org.hibernate.validator.constraints.time.DurationMax.message=musi być którszy niż${inclusive == true ? ' lub równy do' : ''}${days == 0 ? '' : days == 1 ? ' 1 day' : ' ' += days += ' days'}${hours == 0 ? '' : hours == 1 ? ' 1 hour' : ' ' += hours += ' hours'}${minutes == 0 ? '' : minutes == 1 ? ' 1 minute' : ' ' += minutes += ' minutes'}${seconds == 0 ? '' : seconds == 1 ? ' 1 second' : ' ' += seconds += ' seconds'}${millis == 0 ? '' : millis == 1 ? ' 1 milli' : ' ' += millis += ' millis'}${nanos == 0 ? '' : nanos == 1 ? ' 1 nano' : ' ' += nanos += ' nanos'}
org.hibernate.validator.constraints.time.DurationMin.message=musi być dłuższy niż${inclusive == true ? ' or equal to' : ''}${days == 0 ? '' : days == 1 ? ' 1 day' : ' ' += days += ' days'}${hours == 0 ? '' : hours == 1 ? ' 1 hour' : ' ' += hours += ' hours'}${minutes == 0 ? '' : minutes == 1 ? ' 1 minute' : ' ' += minutes += ' minutes'}${seconds == 0 ? '' : seconds == 1 ? ' 1 second' : ' ' += seconds += ' seconds'}${millis == 0 ? '' : millis == 1 ? ' 1 milli' : ' ' += millis += ' millis'}${nanos == 0 ? '' : nanos == 1 ? ' 1 nano' : ' ' += nanos += ' nanos'}
