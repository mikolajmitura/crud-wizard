
pl.jalokim.crudwizard.core.validation.javax.WhenFieldIsInStateThenOthersShould.message={nestedMessage} - but only when the field {whenField} {is}{fieldValues}
pl.jalokim.crudwizard.core.validation.javax.FieldShouldWhenOther.message=should {should}{fieldValues} when field {whenField} {is}{otherFieldValues}
pl.jalokim.crudwizard.core.validation.javax.FieldShouldWhenOther.messageWithoutWhen=should {should}{fieldValues}

shouldBe.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.NULL=be null
whenIs.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.NULL=is null
shouldBe.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.NOT_NULL=be not null
whenIs.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.NOT_NULL=is not null
shouldBe.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.EQUAL_TO_ANY=be equals to any of:
whenIs.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.EQUAL_TO_ANY=is equals to at least one from:
shouldBe.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.CONTAINS_ALL=contains all:
whenIs.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.CONTAINS_ALL=contains all:
shouldBe.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.CONTAINS_ANY=contains one of:
whenIs.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.CONTAINS_ANY=contains one of:
shouldBe.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.NOT_EQUAL_TO_ALL=not be equal to ony of:
whenIs.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.NOT_EQUAL_TO_ALL=is other than others:
shouldBe.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.EMPTY=be empty
whenIs.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.EMPTY=is empty
shouldBe.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.EMPTY_OR_NULL=be empty or null
whenIs.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.EMPTY_OR_NULL=is empty or null
shouldBe.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.NOT_BLANK=not be empty
whenIs.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.NOT_BLANK=is not empty
shouldBe.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.NOT_EMPTY=not be empty
whenIs.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.NOT_EMPTY=is not empty
shouldBe.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.MIN=have size/value greather than or equal:
whenIs.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.MIN=have size/value greather than or equal:
shouldBe.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.MAX=have size/value lower than or equal:
whenIs.pl.jalokim.crudwizard.core.validation.javax.ExpectedFieldState.MAX=have size/value lower than or equal:

pl.jalokim.crudwizard.genericapp.metamodel.endpoint.validation.PathParamsAndUrlVariablesTheSame.message=variables URL from '{baseUrl}' must match field names from {fieldName}: '{fieldNames}'
pl.jalokim.crudwizard.genericapp.metamodel.endpoint.validation.PathParamsAndUrlVariablesTheSame.allFieldsShouldHasClassName=all variables URL must be simple class Long or String

pl.jalokim.crudwizard.genericapp.metamodel.endpoint.validation.EndpointNotExistsAlready.crudWizardController=Url: '{url}' and with HTTP method: '{httpMethod}' is occupied already by endpoint with URL: '{foundUrl}' and with operation name '{foundOperationName}'
pl.jalokim.crudwizard.genericapp.metamodel.endpoint.validation.EndpointNotExistsAlready.springRestController=Url: '{url}' and with HTTP method: '{httpMethod}' is occupied already by Spring RestController: {restClassAndMethod}'

pl.jalokim.crudwizard.genericapp.metamodel.endpoint.validation.DataStorageResultsJoinCorrectness.invalidJoinersNumber=incorrect quantity in relation to the number of data sources
pl.jalokim.crudwizard.genericapp.metamodel.endpoint.validation.DataStorageResultsJoinCorrectness.nonUniqueDsOrQueryName=The query name or data source name should be unique
pl.jalokim.crudwizard.genericapp.metamodel.endpoint.validation.DataStorageResultsJoinCorrectness.notFound=This value was not found in the query or data source names.
pl.jalokim.crudwizard.genericapp.metamodel.endpoint.validation.DataStorageResultsJoinCorrectness.existsInTheSameGroupAlready=Query or data source names already exist in the group: {0}
pl.jalokim.crudwizard.genericapp.metamodel.endpoint.validation.DataStorageResultsJoinCorrectness.notOneGroupResults=Invalid join result. Groups found: {0} and there should be one.
pl.jalokim.crudwizard.genericapp.metamodel.endpoint.validation.DataStorageResultsJoinCorrectness.notTheSameTypesForJoin=different data types for left joins: {leftType}, for right join: {rightType}

ResourceChangedException.default.message=Resource was modified by other user
EntityNotFoundException.default.message=Cannot find resource with id: {0}
EntityNotFoundException.default.concrete.message=Cannot find resource with id: {0} for table: {1}

ClassMetaModelTypeExtractor.invalid.path=path: '{currentPath}' resolved to type: {currentNodeType} it does not contain field with name '{fieldName}'.
ClassMetaModelTypeExtractor.not.expected.any.field=path: '{currentPath}' resolved to type: {currentNodeType} is simple type, cannot have fields

pl.jalokim.crudwizard.core.validation.javax.ClassExists.message=Cannot find class or is not subtype of: {expectedOfType}
pl.jalokim.crudwizard.core.validation.javax.UniqueValue.message=Provided value shoud be unique
pl.jalokim.crudwizard.genericapp.metamodel.datastorage.validation.VerifyThatCanCreateDataStorage.message=Cannot find default factory for data storage
classMetaModel.java.lang.String=Text
